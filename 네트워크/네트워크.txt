
### OSI 7계층
네트워크에서 통신이 일어나는 과정을 7단계로 나눈 것
7. 응용 : HTTP, FTP, DNS
     - 최종목적지. 응용 서비스 수행
6. 표현 : JPEG, MPEG
     - 데이터 표현에 대한 독립성, 암호화 제공
5. 세션 : Socket, API
     - TCP/IP의 세션을 만들고 없애는 책임
4. 전송 : TCP / UDP (Port)
     - TCP와 UDP를 통해 통신을 활성화 - 세그먼트
3. 네트워크 : 라우터 (IP 통신)
     - 라우팅를 통해 이동할 경로를 선택하여 IP를 지정, 패킷 전달
2. 데이터링크 : 스위치, 브릿지 (MAC 통신)
     - 프레임에 MAC주소를 부여하고 전송의 흐름제어를 진행
1. 물리 : 리피터, 허브 (전기신호)
     - 데이터 전기적인 신호

### TCP/IP
TCP/IP는 OSI 참조 모델을 기반으로 상업적이고 실무적으로 이용될 수 있도록 단순화된 모형입니다.
4. 응용 : OSI 7계층에서 5,6,7 계층이며 응용 서비스를 수행
3. 전송(세그먼트) : TCP와 UDP를 통해 통신을 활성화
2. 인터넷(패킷) : 라우팅를 통해 이동할 경로를 선택하여 IP를 지정, 패킷 전달
1. 네트워크 연결(프레임) :프레임에 MAC주소를 부여하고 전송의 흐름제어를 진행

### 라우터/게이트웨이
라우터는 3계층에서 라우터를 통해 이동할 경로를 선택하여 IP를 지정, 패킷을 전달하며 게이트웨이는 프로토콜이 다른 네트워크를 연결할 때 주로 사용됩니다.
요즘에는 라우터와 게이트웨이 기능이 같이 있는 장비를 같이 사용하는 추세입니다.

### 웹 동작 방식
(URL입력)
사용자가 브라우저에 URL을 입력하면 DNS를 통해 서버의 IP주소를 찾습니다. 그 후 HTTP 프로토콜을 사용하여 HTTP요청 메시지를 생성합니다. TCP/IP 연결을 통해 HTTP 요청이 서버로 전송됩니다. 서버는 응답메시지를 요청한 컴퓨터에 전송합니다. 컴퓨터에 도착한 HTTP 응답메시지는 웹페이지로 변환되어 사용자가 볼 수 있게됩니다.

### GET/POST
GET은 데이터를 조회하기 위해 사용되며 URL에 데이터가 노출되기 때문에 보안이 중요한 데이터를 포함하면 안됩니다.
POST는 데이터를 추가하거나 수정하기 위해 사용되며 데이터를 body에 추가하여 전송합니다. 

### TCP/UDP
TCP는 신뢰성 있는 통신을 통해 사용되는 프로토콜로 높은 신뢰성을 보장하지만 UDP보다 속도가 느립니다. 3 way(연결설정), 4way(해제) handshake로 서버와 클라이언트가 1:1로 연결이되며 흐름제어와 혼잡제어가 이루어집니다.
UDP는 비연결형 프로토콜로, 손상된 데이터에 대해서 재전송하지 않으며 신뢰성이 낮지만 TCP보다 속도가 빨라서 스트리밍같은 서비스에 주로 사용이됩니다. 마지막으로 1:1, 1:다, 다:다 연결이 가능합니다.

### 3 way handshake
클라이언트가 서버에 syn 패킷을 보냅니다.
서버가 패킷을 받고 응답신호인 ack 패킷과 syn 패킷을 보냅니다.
클라이언트는 응답신호인 ack를 보내 연결이 성립됩니다.
- 4 way handshake : 데이터를 모두 보낸 후 연결이 종료되었다는 FINISH 플래그를 클라이언트에 보냅니다.

### 흐름제어/혼잡제어
 흐름제어는 송식측 속도가 수신측 속도보다 빠른 경우 문제가 생깁니다. 데이터가 손실될 수 있어 수신측에따라 송신측에서 전송량 속도를 조절합니다.
 혼잡제어는 라우터에 데이터가 몰릴 경우 모두 처리할 수 없기에 네트워크의 혼잡을 피하기 위해 송신측에서 전송량 속도를 조절해야 합니다.

### IP
인터넷을 통해 패킷을 전달하는 프로토콜입니다. 비신뢰성(ICMP해결)과 비연결성의 특징을 가지며 비신뢰성은 패킷의 완전한 전달을 보장하지 않는 것이며 비연결성은 패킷을 보내는 길을 결정하지 않는 것입니다.

### ICMP, IGMP, ARP, RARP
ICMP : IP 전송의 오류메시지를 제공
IGMP : muticast 서비스
ARP : IP를 통해 MAC주소를 알고자 할 때
RARP : MAC주소를 통해 IP주소를 알고자 할 때

### 공인IP / 사설IP
공인IP는 전세계에서 유일한 IP로 ISP가 제공하는 주소입니다.
사설IP는 어떠한 네트워크 내부에서만 사용되며 라우터를 통해 할당받는 가상 주소입니다.

### DNS
도메인 주소를 IP주소로 변환해주는 시스템입니다. DNS은 다음과 순서로 작동을 하게 됩니다.
 첫 번째로, URL을 입력하면 ISP가 관리하는 DNS 해석기에 라우팅을 요청합니다. 그 다음에 DNS해석기 루트 서버에 top-level의 서버 주소를 요청합니다. 
그 후 top-level에서 second-level, second-level에서 sub DNS server로 진행이되어 최종적으로 IP주소를 얻게 됩니다.

### 프록시(=대리) 서버
클라이언트가 자신을 통해 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 서버입니다. 프록시 서버는 요청된 내용들을 캐시를 이용하여 저장합니다. 이를 통해 두 번째부터 빠른 속도로 읽을 수 있습니다.

### HTTP / HTTPS
 HTTP는 평문 데이터를 전송하는 프로토콜이기 때문에, HTTP로 비밀번호나 주민번호 등을 주고 받으면 제3자에 의해 조회될 수 있습니다. 이러한 문제를 해결하기 위해 HTTP에 암호화가 추가된 프로토콜이 HTTPS입니다. 
 HTTPS는 자신의 공개키를 갖는 인증서를 발급하여, 보내는 메시지를 공개키로 암호화하도록 하고 있습니다. 공개키로 암호화된 메시지는 개인키를 가지고 있어야만 복호화가 가능하여 기업을 제외한 누구도 원본 데이터를 얻을 수 없습니다.

### HTTP 응답코드
- 1xx : 요청을 받아서 처리하고 있음
2xx : Request가 성공적으로 처리
  - 200(성공): 서버가 요청을 제대로 처리했다는 뜻
  - 202(허용됨): 서버가 요청을 접수했지만, 아직 처리하지 않았음
3xx (리다이렉션) : 클라이언트를 지정한 위치로 이동
  - 301(영구 이동): 요청한 페이지를 새 위치로 영구적으로 이동
  - 302(임시 이동): 현재 서버가 다른 위치의 페이지로 요청에 응답하고 있지만 요청자는 향후 요청 시 원래 위치를 계속 사용해야 함
4xx (클라이언트 오류) : 요청이 잘못되거나 권한이 없을 때
  - 400(잘못된 요청): 서버가 요청의 구문을 인식하지 못함
  - 401(권한 없음)
  - 403(Forbidden, 금지됨): 서버가 요청을 거부
  - 404(Not Found, 찾을 수 없음): 서버가 요청한 페이지(Resource)를 찾을 수 없음
  - 405(허용되지 않는 방법): 요청에 지정된 방법을 사용할 수 없음
    + 예를 들어 POST 방식으로 요청을 받는 서버에 GET 요청을 보내는 경우, 또는 읽기 전용 리소스에 PUT 요청을 보내는 경우에 이 코드를 제공
5xx (서버 오류) : 서버가 요청을 수행하지 못할 때 발생
  - 500(내부 서버 오류): 서버에 오류가 발생
  - 503(서비스를 사용할 수 없음): 서버가 오버로드되었거나 유지관리를 위해 다운되었기 때문에 현재 서버를 사용할 수 없음

### 로드밸런서
서버의 부하를 분산시켜주는 시스템입니다. 크게 L4 로드밸런서와 L7로드 밸런서가 있습니다.
L4로드밸런서는 4계층 이하의 정보를 가지고 로드를 분산합니다. 특히 MAC주소, IP주소, 포트정보를 통해 트래픽을 분산해줍니다.
L7로드밸런서는 7계층의 정보를 가지고 로드를 분산합니다. 패킷내용을 확인하고 분산해서 DDoS같은 비정상적인 트래픽을 필터링할 수 있습니다.

### 대칭키 / 공개키
 대칭키는 암호화, 복호화에 같은 키를 사용하는 알고리즘입니다. 동일한 키로 속도가 빠르지만 해킹 위험이 있습니다.
 공개키는 공개키로 암호화하지만, 개인키로만 복호화가 가능한 알고리즘입니다. 

### TTL/SSL handshake
(통신과정)
1. 클라이언트->서버 : (클라이언트가 생성한 랜덤데이터 + 클라이언트가 가능한 암호화 방식)을 보냄
2. 서버->클라이언트 : (서버가 생성한 랜덤데이터 + 서버가 선택한 암호화방식 + CA인증서) 보냄
3. 클라이언트 : CA인증서가 유효한지 확인
4. 클라이언트는 (클라이언트가 생성한 랜덤데이터 + 서버가 생성한 랜덤데이터 + a)를 조합하여 대칭키를 완성
5. 클라이언트->서버 : 대칭키를 암호화하여 서버에 전송
6. 서버는 자신의 개인키로 서버의 공개키로 암호화한 대칭키 복호화
이를 통해 클라이언트와 서버는 대칭키를 나눠갖고 통신을 진행합니다.
